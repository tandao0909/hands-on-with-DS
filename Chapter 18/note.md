*Reinforcement learning* is arguably one of the most exciting field of machine learning (also the one attracts me to ML), and also one the oldest. It has been around since 1950s, producing many interesting applications over the years, especially in games (e.g., *TD-Gammon*, a Backgammon-playing program), and in machine control, but seldom making the headline news. However, a revolution happened in [2013](https://arxiv.org/abs/1312.5602), when researchers from DeepMind demonstrated a system that could play any Atari game from scratch, eventually [outperforming human](https://storage.googleapis.com/deepmind-media/dqn/DQNNaturePaper.pdf) in most of them, using only raw pixels as input and without any prior knowledge about the rule of the games. This was just the beginning, followed by the victory of their system AlphaGo against Lee Sedol, a professional player of the Go game, in March 2013 and against Ke Jie, the world champion, in May 2017. No program had ever close to beating a pro player of the game, let alone the world champion. Today, the field of RL is boiled with new ideas, with a huge range of applications.

How did DeepMind(Bought by Google in 2014) do such feats? With hindsight it seems simple: they applied the power of deep learning to the field of reinforcement learning, and it worked beyond their wildest dreams. In this chapter, we'll discover what reinforcement learning is and what it's good at, then present two of the most important techniques in deep reinforcement learning: policy gradients and deep Q-networks, including a discussion of Markov decision progress.

# Learning to Optimize Rewards

In reinforcement learning, a software *agent* makes *observations* and takes *actions* within the environment,a nd in return it receives *rewards* from the environment. Its objective is to learn how to maximize its expected rewards over time. You can think of positive rewards as pleasure, and negative rewards as pain (the term "reward" is a bit misleading here). In short, the agent acts in the environment and learns by trial and error to maximize its pleasure and minimize its pain.

This's quite a board setting, which can be applied to a wide variety of tasks. Here are a few examples:
- The agent can be the program controlling a robot. The environment then can be the real world, the agent observes the world through a set of *sensors*, such as cameras and touch sensors, and its actions consists of sending signals to active motors. It may be programmed to get positive rewards whenever it approaches the target destination, and negative rewards if it falls or waste time.
- The agent can be the the program playing the game of *Ms. Pac-Man*. In this case, the environment is a stimulation of the game, the actions are nine possible joysticks positions (upper left, down, center, and so on), the observations is the game screenshot, and the rewards is the game points.
- Similarly, the agent can be the program playing a board game such as Go. It will only be rewarded if it wins.
- The agent does not have to control a physically (or virtually) moving thing. For example, it cna be a thermostat, getting positive rewards whenever it is close to the target temperature and saves energy, and negative rewards when human needs to tweak the temperature, so the agent must learn to anticipate the human desires.
- The agent can observe stock market prices and decide how much to buy or sell every second. Rewards are obviously the number of money earned.

Note that there may not be any positive reward at all. For example, the agent may move around in a maze, get a negative reward every second at every time step, so it had to find the exit as quick as possible.

There are many other applications for reinforcement learning, such as self-driving cars, recommender system, placing ads on a web page, or control where an image classification system should focus its attention.

# Policy Search

The algorithm the agent used ot define its actions is called a *policy*. It's can be as simple as a bunch of hardcode if/else, to as complex as a whole deep stack of neural network. It must take observations as inputs and output the action to take.

![Reinforcement learning using a neural network policy](image.png)

The policy can be any algorithm you think about, and it doesn't have to be deterministic (we will talk about a probabilistic one soon). In fact, sometimes it does not even have to observe the environment at all! For instance, consider a robotic vacuum cleaner whose reward is the amount of dust it has colleted during 30 minutes. Its policy could be moving forward with some probability p, or randomly rotate left or right with probability 1-p. the rotation angle would be random from -r to r. Since this policy involves some randomness, it's called a *stochastic policy*. The robot will have an erratic trajectory, which guarantees it will eventually get to any place it can get and pick up all the dust. The question is how much dust it can picked up in 30 minutes?

How should you train this model? There are two *policy parameters* to tweak: the probability to move forward p and the angle range r. One possible is to try every possible combination, but this is not a good use of resources. An improved way is to try a bunch of random probability parameters and choose the combination that performs best. this is an example of *policy search*, in this case using a brute-force attack. When the *policy space* is too large (which is generally the case), finding a good set of parameters this way is like finding a needle in a big haystack.

![Four points in the policy space (left) and the agentâ€™s corresponding behavior (right)](image-1.png)

Another way is to use *genetic algorithm*. For example, you could randomly create a first generation of 100 policies and try them out, then "kill" the worst 80 policies (though it's maybe better to keep some of them, to persevere gene diversity) and make the 20 survivors produce 4 offsprings each. An offspring is a copy of its parent, plus some random variation. The surviving policies and their offsprings together run through the second run. if there is a single parent, this is called *asexual reproduction*. With two (or more) parents, it is called *sexual reproduction*. An offspring's genome (in this case is a set of policy parameter) is randomly composed of parts of its parents' genomes. You can continue to iterate though generations this way until you find a good enough policy. One interesting example of genetic algorithm sued for reinforcement learning is the [NeuroEvolution of Augmenting Topologies](https://neat-python.readthedocs.io/en/latest/neat_overview.html) (NEAT) algorithm. You can also check out this [video](), which implements and teaches a lot about this approach (this is my personal recommendation).

Yet another approach is to use optimization techniques, by evaluating the gradients of the rewards with regard to the policy parameters, then tweaking these parameter by following these gradients toward higher rewards. This is called *gradient ascent*: It's just like gradient descent, but in the opposite direction: maximizing instead of minimizing. We will talk about this approach in more detail later in this chapter. Going back to the vacuum cleaner example, we could slightly increase p and evaluate whether doing so increases the amount of dust picked up by the robot in 30 minutes; if it does, then increase p some more; if it doesn't, decrease it instead. We'll implement a popular PG (*policy gradient*) using TensorFlow, but first we need to create an environment for the agent ot live in - so it's time to introduce OpenAI Gymnasium.